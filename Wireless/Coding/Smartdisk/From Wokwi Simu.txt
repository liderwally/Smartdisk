#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "driver/spi_master.h"
#include "esp_log.h"
#include <string.h>
#include "esp_system.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "nvs_flash.h"
#include "lwip/err.h"
#include "lwip/sys.h"
#include "sdkconfig.h"
#include <sys/stat.h>
#include <unistd.h>
#include "esp_idf_version.h"
#include "esp_flash.h"
#include "esp_http_server.h"
#include "driver/sdmmc_host.h"
#include "esp_vfs_fat.h"
// #if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5, 0, 0)
// #include "esp_chip_info.h"
// #include "spi_flash_mmap.h"
// #endif

//**************************************** functions declarations*****************************************
esp_err_t sd_card_mount(void);
static void wifi_event_handler(void* arg, esp_event_base_t event_base,int32_t event_id, void* event_data);
wifi_event_ap_staconnected_t* ableevent;
wifi_event_ap_stadisconnected_t* disableevent;

// ************************SPI BUS***********************************
#define CLK_PIN     12
#define MOSI_PIN    13
#define MISO_PIN    14
#define CS_PIN      10

// #define DECODE_MODE_REG     0x09
// #define INTENSITY_REG       0x0A
// #define SCAN_LIMIT_REG      0x0B
// #define SHUTDOWN_REG        0x0C
// #define DISPLAY_TEST_REG    0x0F

// spi_device_handle_t spi2;
// static esp_err_t spi_init(void);

// static esp_err_t spi_init() {
//   esp_err_t ret;

//   spi_bus_config_t buscfg = {
//     .miso_io_num = MISO_PIN,
//     .mosi_io_num = MOSI_PIN,
//     .sclk_io_num = CLK_PIN,
//     .quadwp_io_num = -1,
//     .quadhd_io_num = -1,
//     .max_transfer_sz = 32,
//   };

//   ret = spi_bus_initialize(SPI2_HOST, &buscfg, SPI_DMA_CH_AUTO);
//   ESP_ERROR_CHECK(ret);

//   spi_device_interface_config_t devcfg = {
//     .clock_speed_hz = 1000000,  // 1 MHz
//     .mode = 0,                  //SPI mode 0
//     .spics_io_num = CS_PIN,
//     .queue_size = 1,
//     .flags = SPI_DEVICE_HALFDUPLEX,
//     .pre_cb = NULL,
//     .post_cb = NULL,
//   };

//   ESP_ERROR_CHECK(spi_bus_add_device(SPI2_HOST, &devcfg, &spi2));

//   return ESP_OK ;
// };

//******************************** virtual File system *****************************************

#define TAG         "sdcard"
#define mount_point "/sdcard"
#define  CONFIG_EXAMPLE_FORMAT_IF_MOUNT_FAILED true
sdmmc_card_t *card;



esp_err_t sd_card_mount(void) {
  esp_err_t ret;

  // Options for mounting the filesystem.
  // If format_if_mount_failed is set to true, SD card will be partitioned and
  // formatted in case when mounting fails.

  esp_vfs_fat_sdmmc_mount_config_t mount_config = {
#if CONFIG_EXAMPLE_FORMAT_IF_MOUNT_FAILED 
    .format_if_mount_failed = true,
#else
    .format_if_mount_failed = false,
#endif 
    .max_files = 5,
    .allocation_unit_size = 64 * 1024
  };


  printf("Initializing SD card\n\r");

  // Use settings defined above to initialize SD card and mount FAT filesystem.
  // Note: esp_vfs_fat_sdmmc/sdspi_mount is all-in-one convenience functions.
  // Please check its source code and implement error recovery when developing
  // production applications.

  // ESP_LOGI(TAG, "Using SPI peripheral");

  sdmmc_host_t host = SDSPI_HOST_DEFAULT();
  host.slot = SPI3_HOST;
  host.max_freq_khz = 4000;

  spi_bus_config_t bus_cfg = {
    .mosi_io_num = MOSI_PIN,
    .miso_io_num = MISO_PIN,
    .sclk_io_num = CLK_PIN,
    .quadwp_io_num = -1,
    .quadhd_io_num = -1,
    .max_transfer_sz = 0,
  };
  ret = spi_bus_initialize(host.slot, &bus_cfg, SDSPI_DEFAULT_DMA);
  if (ret != ESP_OK) {
    ESP_LOGE(TAG, "Failed to initialize bus.");
    return ret;
  }

  // This initializes the slot without card detect (CD) and write protect (WP) signals.
  // Modify slot_config.gpio_cd and slot_config.gpio_wp if your board has these signals.
  sdspi_device_config_t slot_config = SDSPI_DEVICE_CONFIG_DEFAULT();
  slot_config.gpio_cs = CS_PIN;
  slot_config.host_id = host.slot;

  ESP_LOGI(TAG, "Mounting filesystem");
  ret = esp_vfs_fat_sdspi_mount(mount_point, &host, &slot_config, &mount_config, &card);

  if (ret != ESP_OK) {
    if (ret == ESP_FAIL) {
      printf(
               "Failed to mount filesystem. "
               "If you want the card to be formatted, set the CONFIG_EXAMPLE_FORMAT_IF_MOUNT_FAILED menuconfig option.");
    } else {
      printf(
               "Failed to initialize the card (%s). "
               "Make sure SD card lines have pull-up resistors in place.",
               esp_err_to_name(ret));
    }
    return ret;
  }
  ESP_LOGI(TAG, "Filesystem mounted");
  // Card has been initialized, print its properties
  // sdmmc_card_print_info(stdout, card);
  return ret;
}

esp_err_t sd_card_unmount(void) {
  esp_err_t ret;
  // All done, unmount partition and disable SPI peripheral
  ret = esp_vfs_fat_sdcard_unmount(mount_point, card);
  ESP_LOGI(TAG, "Card unmounted");

  // deinitialize the bus after all devices are removed
  // spi_bus_free(host.slot);
  return ret;
}

//********************************** WIFI_SOFT_AP  *******************************************************/

/* The examples use WiFi configuration that you can set via project configuration menu.

   If you'd rather not, just change the below entries to strings with
   the config you want - ie #define WIFI_SSID "mywifissid"
*/
#define ESP_WIFI_SSID      "Wawako"
#define ESP_WIFI_PASS      "mimisijui"
#define ESP_WIFI_CHANNEL   6
#define MAX_STA_CONN       5
#define MACSTR "WUSBFD"
// static const char *TAG = "wifi softAP";

static void wifi_event_handler(void* arg, esp_event_base_t event_base,
                               int32_t event_id, void* event_data)
{
  if (event_id == WIFI_EVENT_AP_STACONNECTED) {
    ableevent= (wifi_event_ap_staconnected_t*) event_data;

    // ESP_LOGI(TAG, "station MACSTR join, AID=%d",MAC2STR(event->mac), ableevent->aid);

  } else if (event_id == WIFI_EVENT_AP_STADISCONNECTED) {
    disableevent = (wifi_event_ap_stadisconnected_t*) event_data;

    // ESP_LOGI(TAG, "station MACSTR leave, AID=%d",MAC2STR(event->mac), disableevent->aid);
  }
}


wifi_config_t wifi_config = {
  .ap = {
    .ssid = ESP_WIFI_SSID,
    .ssid_len = strlen(ESP_WIFI_SSID),
    .channel = ESP_WIFI_CHANNEL,
    .password = ESP_WIFI_PASS,
    .max_connection = MAX_STA_CONN,
    .authmode = WIFI_AUTH_WPA_WPA2_PSK
  },
};


void wifi_init_softap(void)
{
  ESP_ERROR_CHECK(esp_netif_init());
  ESP_ERROR_CHECK(esp_event_loop_create_default());
  esp_netif_create_default_wifi_ap();

  wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
  ESP_ERROR_CHECK(esp_wifi_init(&cfg));

  ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,
                  ESP_EVENT_ANY_ID,
                  &wifi_event_handler,
                  NULL,
                  NULL));


  if (strlen(ESP_WIFI_PASS) == 0) {
    wifi_config.ap.authmode = WIFI_AUTH_OPEN;
  }

  ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP));
  ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_AP, &wifi_config));
  ESP_ERROR_CHECK(esp_wifi_start());

  // ESP_LOGI(TAG, "wifi_init_softap finished. SSID:%s password:%s channel:%d",
  //  ESP_WIFI_SSID, ESP_WIFI_PASS, ESP_WIFI_CHANNEL);
}

// ************************ web Server*******************************************************


static void http_server_netconn_serve(struct netconn *conn) {
	struct netbuf *inbuf;
	char *buf;
	u16_t buflen;
	err_t err;

	/* Read the data from the port, blocking if nothing yet there.
	 We assume the request (the part we care about) is in one netbuf */
	err = netconn_recv(conn, &inbuf);

	if (err == ERR_OK) {
		netbuf_data(inbuf, (void**) &buf, &buflen);

		/* Is this an HTTP GET command? (only check the first 5 chars, since
		 there are other formats for GET, and we're keeping it very simple )*/
		if (buflen >= 5 && strncmp("GET ",buf,4)==0) {

			/*  sample:
			 * 	GET /l HTTP/1.1
				Accept: text/html, application/xhtml+xml, image/jxr,
				Referer: http://192.168.1.222/h
				Accept-Language: en-US,en;q=0.8,zh-Hans-CN;q=0.5,zh-Hans;q=0.3
				User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.79 Safari/537.36 Edge/14.14393
				Accept-Encoding: gzip, deflate
				Host: 192.168.1.222
				Connection: Keep-Alive
			 *
			 */
			//Parse URL
			char* path = NULL;
			char* line_end = strchr(buf, '\n');
			if( line_end != NULL )
			{
				//Extract the path from HTTP GET request
				path = (char*)malloc(sizeof(char)*(line_end-buf+1));
				int path_length = line_end - buf - strlen("GET ")-strlen("HTTP/1.1")-2;
				strncpy(path, &buf[4], path_length );
				path[path_length] = '\0';
				//Get remote IP address
				ip_addr_t remote_ip;
				u16_t remote_port;
				netconn_getaddr(conn, &remote_ip, &remote_port, 0);
				printf("[ "IPSTR" ] GET %s\n", IP2STR(&(remote_ip.u_addr.ip4)),path);
			}

			/* Send the HTML header
			 * subtract 1 from the size, since we dont send the \0 in the string
			 * NETCONN_NOCOPY: our data is const static, so no need to copy it
			 */
			bool bNotFound = false;
			if(path != NULL)
			{

				if (strcmp("/high",path)==0) {
					gpio_set_level(LED_PIN,1);
				}
				else if (strcmp("/low",path)==0) {
					gpio_set_level(LED_PIN,0);
				}
				else if (strcmp("/",path)==0)
				{
				
				}
				else
				{
					bNotFound = true;	// 404 Not found
				}
				
				free(path);
				path=NULL;
			}

			// Send HTTP response header
			if(bNotFound)
			{
				netconn_write(conn, http_404_hdr, sizeof(http_404_hdr) - 1,
					NETCONN_NOCOPY);
			}
			else
			{
				netconn_write(conn, http_html_hdr, sizeof(http_html_hdr) - 1,
					NETCONN_NOCOPY);
			}

			// Send HTML content
			netconn_write(conn, http_index_hml, sizeof(http_index_hml) - 1,
					NETCONN_NOCOPY);
		}

	}
	// Close the connection (server closes in HTTP)
	netconn_close(conn);

	// Delete the buffer (netconn_recv gives us ownership,
	// so we have to make sure to deallocate the buffer)
	netbuf_delete(inbuf);
}


static void http_server(void *pvParameters) {
	struct netconn *conn, *newconn;	//conn is listening thread, newconn is new thread for each client
	err_t err;
	conn = netconn_new(NETCONN_TCP);
	netconn_bind(conn, NULL, 80);
	netconn_listen(conn);
	do {
		err = netconn_accept(conn, &newconn);
		if (err == ERR_OK) {
			http_server_netconn_serve(newconn);
			netconn_delete(newconn);
		}
	} while (err == ERR_OK);
	netconn_close(conn);
	netconn_delete(conn);
}


// *********************************** task Handler *******************************************

TaskHandle_t handle1;
TaskHandle_t handle2;

gpio_mode_t out = 1;
gpio_mode_t ins = 0;

#define ledPin 11
#define buttonPin 12
uint32_t ledState = 1;

void blink() {

  while (1) {
    gpio_set_level(GPIO_NUM_11, ledState);
    printf("%ld \n\r", ledState);
    vTaskDelay(1000 / portTICK_PERIOD_MS);
    if (ledState == 0) {
      ledState++;
    }
    else {
      ledState = 0;
    }

  }

}


void server() {
  while (1) {
    gpio_set_level(GPIO_NUM_12, ledState);
    printf("Hello World !\n\r");
    vTaskDelay(1000 / portTICK_PERIOD_MS);
  }

}

//************************************main function*************************************************************
void app_main() {
  gpio_set_direction(CS_PIN, GPIO_MODE_OUTPUT);
  esp_err_t ret0 = sd_card_mount();;
  if (ret0 == ESP_OK ) {
    printf("SPI Bus initiated successfully\n\r");
  }

  esp_err_t ret = nvs_flash_init();
  if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
    ESP_ERROR_CHECK(nvs_flash_erase());
    ret = nvs_flash_init();
  }
  ESP_ERROR_CHECK(ret);

  // ESP_LOGI(TAG, "ESP_WIFI_MODE_AP");
  wifi_init_softap();
  printf("Connect to wifi Access Point with BSSID: %s , passowrd : %s", wifi_config.ap.ssid, wifi_config.ap.password);
  gpio_set_direction(GPIO_NUM_11, GPIO_MODE_OUTPUT);
  gpio_set_direction(GPIO_NUM_12, GPIO_MODE_OUTPUT);

  xTaskCreatePinnedToCore(blink, "task1", 2048, NULL, 6, &handle1, 0);
  xTaskCreatePinnedToCore(server, "task2", 2048, NULL, 6, &handle2, 1);

}
